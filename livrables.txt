Voilà ce qui est attendu, noir sur blanc, d’après le PDF.  ￼

⸻

1. Livrables à rendre

Tu dois déposer une archive ZIP contenant exactement :
	1.	Un rapport en PDF
	•	Contenu :
	•	Travail de conception / normalisation (champs, DF, forme normale avant décomposition, schéma final en 3NF).
	•	Explication de vos choix de modélisation.
	•	Explications sur les contraintes et les triggers que vous avez définis.
	•	Exigences :
	•	Noms des membres du binôme bien indiqués.
	•	Français correct (orthographe/grammaire).
	•	Un minimum de mise en forme / créativité.
	2.	Un fichier bdd_schema.sql
	•	Contient uniquement les commandes de création des tables et toutes leurs contraintes :
	•	CREATE TABLE ...
	•	Clés primaires.
	•	Clés étrangères.
	•	NOT NULL, UNIQUE, autres contraintes.
	•	Définition des TRIGGERS si tu les places dans ce fichier (possible aussi dans l’autre, mais eux les exécuteront de toute façon).
	3.	Un fichier bdd_donnees.sql
	•	Contient :
	•	Les INSERT permettant d’alimenter toutes les tables.
	•	Les requêtes SQL (au moins une douzaine) qui répondent aux besoins métiers.
	•	Éventuellement les TRIGGERS si tu choisis de les mettre là (la prof dit qu’elle exécutera ce fichier et vérifiera “vos requêtes et triggers”).

Important : elle va recréer une base, exécuter bdd_schema.sql, puis exécuter tout le contenu de bdd_donnees.sql et vérifier que tout passe sans erreur.  ￼

⸻

2. Contraintes de conception / normalisation

Dans la partie conception, tu dois respecter :
	1.	Respect strict de la 3ème Forme Normale (3NF)
	•	À partir du schéma donné (ARTISTE, FILM, ALBUM, UTILISATEUR, AVIS, PAYS, PARTICIPE_FILM, HISTORIQUE_PROPOSITION), tu dois :
	1.	Identifier tous les champs présents dans ta BDD finale.
	2.	Lister les dépendances fonctionnelles de la relation de départ.
	3.	Dire quelle forme normale a la relation avant décomposition (1NF, 2NF, 3NF ?) et pourquoi.
	4.	Proposer un schéma en 3NF (tables + attributs + clés primaires).
	5.	Identifier toutes les contraintes référentielles (FK) sur ce schéma.  ￼
	2.	Respect du périmètre fonctionnel
	•	La base doit permettre de gérer :
	•	Les films (titre, année, genre, réalisateur, pays…)
	•	Les albums (titre, année, genre, artiste principal, label…)
	•	Les artistes (nom, pays, naissance, type : réalisateur/acteur/musicien…)
	•	Les utilisateurs/abonnés (nom, âge, pays…)
	•	Les évaluations/avis (films ou albums).
	•	L’historique de propositions (films/musiques proposés à chaque abonné).  ￼

⸻

3. Contraintes SQL techniques

3.1. Types de données imposés

Tu dois utiliser exactement ces types :  ￼
	•	Texte : varchar(30) pour tous les champs texte (taille fixe de 30).
	•	Entiers : integer (pour id, âges, etc.).
	•	Heure : time ('hh:mm:ss').
	•	Date+heure : timestamp ('aa/mm/jj hh:mm:ss').
	•	Durée jours+heures : interval ('jj hh:mm:ss').
	•	Durée en jours : integer.

3.2. Contraintes à implémenter

Dans bdd_schema.sql :
	•	Clés primaires sur chaque table (PRIMARY KEY(...)).
	•	Clés étrangères cohérentes avec le schéma donné :
	•	FILM.idRealisateur → ARTISTE.idArtiste
	•	FILM.codePays → PAYS.codePays
	•	ALBUM.idArtistePrincipal → ARTISTE.idArtiste
	•	AVIS.idUser → UTILISATEUR.idUser
	•	AVIS.idFilm → FILM.idFilm
	•	AVIS.idAlbum → ALBUM.idAlbum
	•	PARTICIPE_FILM.idArtiste → ARTISTE.idArtiste
	•	PARTICIPE_FILM.idFilm → FILM.idFilm
	•	HISTORIQUE_PROPOSITION.idUser → UTILISATEUR.idUser
	•	HISTORIQUE_PROPOSITION.idFilm → FILM.idFilm
	•	HISTORIQUE_PROPOSITION.idAlbum → ALBUM.idAlbum
	•	NOT NULL pour les champs obligatoires (ex : noms, titres, dates essentielles…).
	•	UNIQUE là où c’est logique (ex : PAYS.codePays).  ￼

⸻

4. Requêtes métiers (~12 requêtes)

Le sujet impose :  ￼
	•	“Fournir une douzaine de requêtes illustrant les cas métiers”, et pour chaque requête :
	•	Expliquer les résultats attendus dans le rapport (pas seulement le code).
	•	Les requêtes doivent couvrir :
	•	Recherche multicritère (par artiste, genre, décennie, etc.).
	•	Statistiques (top 5 films/albums par note, genre préféré par tranche d’âge…).
	•	Suivi des évaluations récentes.
	•	Recommandations simples.

Concrètement, ça veut dire :
	•	Au moins ≈ 12 SELECT avec JOIN, GROUP BY, HAVING, ORDER BY, etc.
	•	Une explication textuelle dans le rapport pour chaque requête :
“Cette requête sert à … Elle renvoie … (champs)”.

Ces requêtes seront testées lors de l’exécution de bdd_donnees.sql.

⸻

5. Triggers & contraintes supplémentaires

Même si ce n’est pas listé comme une contrainte “bullet point” dans la section Contraintes, la prof :
	•	Dit qu’elle va vérifier “vos explications sur les contraintes et triggers” dans le rapport.
	•	Dit qu’elle va exécuter bdd_donnees.sql et vérifier “toutes vos requêtes et triggers”.  ￼

Donc, il est attendu que tu mettes en place au moins quelques triggers pour faire respecter des règles métier, par exemple :
	•	Bornes de la note dans AVIS (ex : empêcher note hors [1,5]).
	•	Cohérence film/album dans AVIS :
	•	soit idFilm non NULL, soit idAlbum non NULL (et tu peux interdire que les deux soient non NULL).
	•	Contrôle d’intégrité supplémentaire (éventuellement empêcher un AVIS pour un film inexistant si tu as des contraintes particulières).

Ces triggers doivent :
	•	Être définis en SQL.
	•	Être expliqués dans le rapport (objectif, exemple de cas bloqué).

⸻

6. Structure des fichiers et contraintes de rendu

Enfin, sur la structure du rendu :  ￼
	•	Nomenclature des fichiers OBLIGATOIRE :
	•	rapport.pdf
	•	bdd_schema.sql
	•	bdd_donnees.sql
	•	Avant de rendre :
	1.	Créer une nouvelle base.
	2.	Exécuter bdd_schema.sql.
	3.	Exécuter bdd_donnees.sql.
	4.	Vérifier qu’il n’y a aucune erreur.
	•	Si :
	•	Noms de fichiers incorrects,
	•	Code qui ne s’exécute pas,
	•	Besoin de modifier ton code pour que ça marche,
	•	Requêtes ou triggers faux,
⇒ perte de points.

⸻

Si tu veux, je peux maintenant t’aider à faire la checklist détaillée de ton rapport (titres de sections + ce que vous devez écrire exactement pour chaque contrainte, chaque trigger, chaque requête).